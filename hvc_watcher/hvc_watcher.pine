// Copyright 2025 Major Hayden
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//@version=6
indicator('HVC Watcher', shorttitle = 'HVC Watch', overlay = true, max_boxes_count = 100, max_labels_count = 500)

// Input parameters
sma_length = input.int(20, title = 'Volume SMA Length', minval = 1)
volume_multiplier = input.float(3.0, title = 'Volume Multiplier for High Volume', minval = 1.0, step = 0.1)
low_volume_threshold = input.float(0.5, title = 'Low Volume Threshold (fraction of SMA)', minval = 0.1, maxval = 1.0, step = 0.1)

// Time filtering inputs
enableTimeFilter = input.bool(false, 'Enable Time Filter', group = 'Volume Filtering', tooltip = 'Filter volume to specific hours (NYC time). Works on both intraday and daily timeframes.')
startHour = input.int(10, 'Start Hour', minval = 0, maxval = 23, group = 'Volume Filtering')
startMinute = input.int(30, 'Start Minute', minval = 0, maxval = 59, group = 'Volume Filtering')
endHour = input.int(15, 'End Hour', minval = 0, maxval = 23, group = 'Volume Filtering')
endMinute = input.int(00, 'End Minute', minval = 0, maxval = 59, group = 'Volume Filtering')
showTimeHeadband = input.bool(true, 'Show Time Filter Headband', group = 'Volume Filtering', tooltip = 'Display time filter settings when time filter is enabled')

// HVC Info Panel settings
showHVCStreak = input.bool(true, 'Show HVC Streak Tracker', group = 'Info Panel', tooltip = 'Display consecutive HVC direction streaks')
infoPanelPosition = input.string('Top Center', 'Info Panel Position', options = ['Top Left', 'Top Center', 'Top Right', 'Middle Left', 'Middle Right', 'Bottom Left', 'Bottom Center', 'Bottom Right'], group = 'Info Panel')

// Color inputs
color_all_time = input.color(color.green, title = 'All-Time High Volume Color')
color_sma_mult = input.color(color.yellow, title = 'High Volume (SMA Multiple) Color')
color_low_volume = input.color(color.red, title = 'Low Volume Color')

// Shape style inputs
shape_style = input.string('circles', title = 'Shape Style', options = ['circles', 'triangleup', 'diamond', 'cross', 'xcross'])

// Priority mode input
priority_mode = input.bool(true, title = 'Use Priority Mode (only show highest priority marker)')

// Rectangle settings for high volume days
show_rectangles = input.bool(false, title = 'Show Rectangles on High Volume Days')
rect_bars_extend = input.int(90, title = 'Rectangle Extension (bars)', minval = 1, maxval = 100)
rect_color = input.color(color.yellow, title = 'Rectangle Color')
rect_transparency = input.int(95, title = 'Rectangle Transparency (%)', minval = 0, maxval = 100)

// Label settings for volume multiplier
show_multiplier_labels = input.bool(false, title = 'Show Volume Multiplier Labels')
label_color = input.color(color.yellow, title = 'Label Text Color')
label_bg_color = input.color(color.new(color.black, 80), title = 'Label Background Color')

// Current bar multiplier label settings
show_current_multiplier = input.bool(false, title = 'Show Current Bar Multiplier (Real-Time)')
current_label_color = input.color(color.white, title = 'Current Bar Label Text Color')
current_label_bg_color = input.color(color.new(color.blue, 50), title = 'Current Bar Label Background Color')

// Function to check if a time is within trading hours (NYC time)
isTimeInRange(t) =>
    barHour = hour(t, 'America/New_York')
    barMinute = minute(t, 'America/New_York')

    // Convert times to minutes for easier comparison
    barTimeInMinutes = barHour * 60 + barMinute
    startTimeInMinutes = startHour * 60 + startMinute
    endTimeInMinutes = endHour * 60 + endMinute

    // Check if bar is within the time range
    barTimeInMinutes >= startTimeInMinutes and barTimeInMinutes <= endTimeInMinutes

// Calculate filtered volume based on timeframe
filteredVolume = if not enableTimeFilter
    volume
else if timeframe.isintraday
    // For intraday charts, just check the current bar's time
    nycTime = time('', 'America/New_York')
    isTimeInRange(nycTime) ? volume : 0
else
    // For daily or higher timeframes, sum volume from lower timeframe bars within the time range
    volArray = request.security_lower_tf(syminfo.tickerid, '30', volume)
    timeArray = request.security_lower_tf(syminfo.tickerid, '30', time)

    float totalVol = 0.0
    if array.size(volArray) > 0
        for i = 0 to array.size(volArray) - 1
            barTime = array.get(timeArray, i)
            if isTimeInRange(barTime)
                totalVol += array.get(volArray, i)
    totalVol

// Calculate volume SMA using filtered volume
volume_sma = ta.sma(filteredVolume, sma_length)

// Check for all-time highest volume (using filtered volume)
var float all_time_high_volume = 0
all_time_high_volume := math.max(all_time_high_volume, nz(filteredVolume[1], 0))
is_all_time_high = filteredVolume > all_time_high_volume and filteredVolume > 0

// Check for volume at least X times the SMA (using filtered volume)
is_sma_multiplier = filteredVolume >= volume_sma * volume_multiplier

// Check if current bar is today and market is still open
is_current_day = barstate.isrealtime and barstate.isconfirmed == false

// Check for exceptionally low volume (50% of SMA or lower)
// Skip low volume check on current day if market is still open (using filtered volume)
is_low_volume = not is_current_day and filteredVolume <= volume_sma * low_volume_threshold

// Function to get the appropriate shape
getShape(style) =>
    switch style
        'circles' => shape.circle
        'triangleup' => shape.triangleup
        'diamond' => shape.diamond
        'cross' => shape.cross
        'xcross' => shape.xcross
        => shape.circle

// Function to convert position string to position constant
getTablePosition(positionStr) =>
    switch positionStr
        'Top Left' => position.top_left
        'Top Center' => position.top_center
        'Top Right' => position.top_right
        'Middle Left' => position.middle_left
        'Middle Right' => position.middle_right
        'Bottom Left' => position.bottom_left
        'Bottom Center' => position.bottom_center
        'Bottom Right' => position.bottom_right
        => position.top_center  // Default fallback

selected_shape = getShape(shape_style)

// Determine which markers to show based on priority mode
// Priority: All-time high > High volume > Low volume
show_all_time = is_all_time_high
show_sma_mult = priority_mode ? is_sma_multiplier and not is_all_time_high : is_sma_multiplier
show_low_volume = priority_mode ? is_low_volume and not is_sma_multiplier and not is_all_time_high : is_low_volume

// HVC Streak Tracking
// Track HVC events (either all-time high or SMA multiplier)
is_hvc = is_all_time_high or is_sma_multiplier

// Store last HVC close price and count streak
var float lastHVCClose = na
var int streakCount = 0
var bool streakUp = true
var bool streakInitialized = false

if is_hvc and barstate.isconfirmed
    if na(lastHVCClose)
        // First HVC, initialize
        lastHVCClose := close
        streakCount := 1
        streakInitialized := false
    else
        // Compare current close to last HVC close
        currentUp = close > lastHVCClose

        if not streakInitialized
            // Second HVC, establish initial direction
            streakUp := currentUp
            streakCount := 2
            streakInitialized := true
        else if currentUp == streakUp
            // Streak continues in same direction
            streakCount += 1
        else
            // Streak changes direction, reset
            streakUp := currentUp
            streakCount := 1

        lastHVCClose := close

// Plot a label above the bar or a yellow circle depending on configuration (using filtered volume)
if show_multiplier_labels and is_sma_multiplier and volume_sma > 0
    multiplier = filteredVolume / volume_sma
    multiplier_rounded = math.round(multiplier)
    label_text = str.tostring(multiplier_rounded) + "x"
    label.new(bar_index, close, label_text,
              color = label_bg_color,
              textcolor = label_color,
              style = label.style_label_right,
              size = size.normal)

plotshape(series = show_all_time, location = location.abovebar, style = selected_shape, size = size.auto, color = color_all_time, title = 'All-Time High Volume')
plotshape(series = show_sma_mult, location = location.abovebar, style = selected_shape, size = size.auto, color = color_sma_mult, title = 'High Volume (SMA Multiple)')
plotshape(series = show_low_volume, location = location.abovebar, style = selected_shape, size = size.auto, color = color_low_volume, title = 'Low Volume')

// Add alerts
alertcondition(is_all_time_high, title = 'All-Time High Volume', message = 'All-time high volume detected on {{ticker}}')
alertcondition(show_sma_mult, title = 'High Volume Spike', message = 'High volume spike detected on {{ticker}} - volume is above SMA threshold')

// Display current values in data window
plot(filteredVolume, title = 'Filtered Volume', display = display.data_window)
plot(volume_sma, title = 'Volume SMA', display = display.data_window)
plot(all_time_high_volume, title = 'All-Time High Volume', display = display.data_window)

// Draw rectangles on high volume days (yellow circles)
if show_rectangles and is_sma_multiplier
    box.new(bar_index, high, bar_index + rect_bars_extend, low, border_color = na, bgcolor = color.new(rect_color, rect_transparency))

// Show real-time multiplier for current bar (using filtered volume)
if show_current_multiplier and barstate.islast and volume_sma > 0
    current_multiplier = filteredVolume / volume_sma
    current_text = str.tostring(current_multiplier, format.mintick) + "x"
    var label current_label = na
    label.delete(current_label)
    current_label := label.new(bar_index, low, current_text,
                              color = current_label_bg_color,
                              textcolor = current_label_color,
                              style = label.style_label_upper_left,
                              size = size.normal)

// Display HVC Info Panel (combined time filter and streak tracker)
if barstate.islast and (showHVCStreak or (enableTimeFilter and showTimeHeadband))
    // Convert user's position choice to position constant
    tablePos = getTablePosition(infoPanelPosition)

    // Determine background color based on streak direction
    panelBgColor = if showHVCStreak and streakInitialized and streakCount > 0
        if streakUp
            color.new(color.green, 70)  // Soft green for upward streaks
        else
            color.new(color.red, 70)    // Soft red for downward streaks
    else
        color.new(color.black, 30)      // Black for no streak or time filter only

    var table infoPanel = table.new(tablePos, 1, 1, bgcolor = panelBgColor, border_width = 1, border_color = color.new(color.gray, 50))

    // Build combined info text
    infoParts = array.new<string>()

    // Add streak info if enabled
    if showHVCStreak
        streakText = if streakCount == 0 or not streakInitialized
            '📊 No HVC streak yet'
        else
            directionText = streakUp ? '⬆️ up' : '⬇️ down'
            '📊 Last ' + str.tostring(streakCount) + ' HVC' + (streakCount > 1 ? 's ' : ' ') + directionText
        array.push(infoParts, streakText)

    // Add time filter info if enabled
    if enableTimeFilter and showTimeHeadband
        startTimeStr = str.format('{0,number,00}:{1,number,00}', startHour, startMinute)
        endTimeStr = str.format('{0,number,00}:{1,number,00}', endHour, endMinute)
        timeText = '⏰ Filter: ' + startTimeStr + ' - ' + endTimeStr + ' (NYC)'
        array.push(infoParts, timeText)

    // Combine parts with separator
    combinedText = array.size(infoParts) > 0 ? array.get(infoParts, 0) : ''
    if array.size(infoParts) > 1
        combinedText += '  |  ' + array.get(infoParts, 1)

    table.cell(infoPanel, 0, 0, combinedText, text_color = color.white, text_size = size.small)
